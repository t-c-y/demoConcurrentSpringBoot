package com.example.demo.jvm.day6;

public class SuspendResumeTest {

    /**
     * 线程挂起和继续执行
     *
     * Thread类中还有2个方法，即线程挂起(suspend)和继续执行(resume)，
     * 这2个操作是一对相反的操作，被挂起的线程，必须要等到resume()方法操作后，
     * 才能继续执行。系统中已经标注着2个方法过时了，不推荐使用。
     *
     * 系统不推荐使用suspend()方法去挂起线程是因为suspend()方法导致线程暂停的同时，
     * 并不会释放任何锁资源。此时，其他任何线程想要访问被它占用的锁时，都会被牵连，
     * 导致无法正常运行。直到在对应的线程上进行了resume()方法操作，
     * 被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。
     * 但是，如果resume()方法操作意外地在suspend()方法前就被执行了，
     * 那么被挂起的线程可能很难有机会被继续执行了。
     * 并且，更严重的是：它所占用的锁不会被释放，因此可能会导致整个系统工作不正常。
     * 而且，对于被挂起的线程，从它线程的状态上看，居然还是Runnable状态，
     * 这也会影响我们队系统当前状态的判断。
     *
     */



}
